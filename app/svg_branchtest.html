<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TEST DAT BRANCHING SON</title>


  <script src="bower_components/snap.svg/dist/snap.svg.js"></script>
  <script src="js/svg_branching.js"></script>
  <link rel='stylesheet' href='http://fonts.googleapis.com/css?family=Libre+Baskerville:400,700' type='text/css'>


</head>
<body style="background: black">

<svg version="1.1"
     id="test"
     xmlns="http://www.w3.org/2000/svg"
     x="0px"
     y="0px"
	 width="700"
     height="700"
     viewBox="0 0 512 512" preserveAspectRatio="xMidYMid"
     xml:space="preserve">
  </svg>

<script>

  var paper = Snap.select('#test');


  function buildBranchLine(x1, y1, x2, y2) {
    var line = group.line(x1, y1, x2, y2);
    line.attr({stroke: '#FFF', 'stroke-width': 2});
    return line;
  }

  var Branch = function (startX, startY, endX, endY, text) {

    this.startX = startX;
    this.startY = startY;
    this.endX = endX;

    this.branchLine = buildBranchLine(startX, startY, startX, startY);


    var textNode;
    if (text) {
      textNode = buildTextNode(text, startX, startY, false, true);
    }

    this.destroyBranch = function () {
      this.animateBranch(this.branchLine, this.endX, this.startX, true);
    };

    this.animateBranch = function (line, from, to, destroying) {
      var branchLine = this.branchLine;
      to = to || endX;
      from = from || startX;
      Snap.animate(
        from,
        to,
        text ? updateHorizontalWithText : updateHorizontal,
        250,
        mina.easeout,
        destroying ? function () {
          branchLine.remove();
          if (textNode) {
            textNode.animate(
              {opacity: 0},
              250,
              function () {
                textNode.remove()
              }
            );
          }
        } : null
      );

      function updateHorizontal(value) {
        line.attr({x2: value});
      }

      function updateHorizontalWithText(value) {
        textNode.attr({x: value});
        updateHorizontal(value);
      }
    };

    this.animateBranch(this.branchLine);
    return this;
  };

  var BranchGroup = function (group) {
    var bBox = group.getBBox();
    var startY = bBox.y2;
    var startX = bBox.cx;
    var branchLength = 100;

    var trunk;
    var branches = [];

    this.destroyBranch = function () {
      branches.forEach(function (elem) {
        elem.destroyBranch();
      });
      trunk.animate(
        {opacity: 0},
        500,
        function () {
          trunk.remove();
        }
      );
    };

    this.makeBranchTo = function (x, y, branchesOnLine) {
      var endY = y;
      var yDistance = (endY - startY);
      var endX = x;
      var xDistance = (endX - startX);

      var isVertical = yDistance > 0 && xDistance == 0;

      var branchPoints = branchesOnLine > 0 ? buildBranchPoints() : [];

      function buildBranchPoints() {
        var branchPoints = new Array(branchesOnLine);
        for (var i = 1; i <= branchesOnLine; i++) {
          branchPoints[i - 1] = startY + (i / branchesOnLine) * yDistance
        }
        return branchPoints
      }

      function animateBranch(line) {
        Snap.animate(
          startY,
          endY,
          isVertical ? updateVertical : updateHorizontal,
          1000
        );


        function updateHorizontal(value) {
          line.attr({x2: value});
        }

        var currentBranch = 0;

        function updateVertical(value) {
          line.attr({y2: value});

          if (currentBranch < branchesOnLine && value >= branchPoints[currentBranch]) {
            ++currentBranch;
            var branch = new Branch(x, value, x + branchLength, value, Math.random().toString(16).substring(2, 10));
            branches.push(branch);
            group.append(branch.branchLine);
          }
        }

      }

      trunk = buildBranchLine(bBox.cx, startY, bBox.cx, endY);
      animateBranch(trunk);

      return this;
    };


  };


  function buildTextNode(text, x, y, centerX, centerY) {
    var textNode = paper.text(-1024, -1024, text);
    var textBBox = textNode.getBBox();
    var height = textBBox.height;
    var width = textBBox.width;
    textNode.attr({
      'font-family': 'Libre Baskerville',
      x: centerX ? (x - width / 2) : x,
      y: centerY ? (y + height / 2) : y,
      fill: '#FFF'
    });
    return textNode;
  }


  function graveButton(x, y, radius, text, numberOfCircles) {
    numberOfCircles = numberOfCircles || 3;

    var group = paper.group();
    group.attr({cursor: 'pointer'})
    var whiteMultiple = 0xFFFFFF / numberOfCircles;
    for (var i = 0; i < numberOfCircles; i++) {
      var fraction = ((numberOfCircles - i) / (numberOfCircles));

      var circle = paper.circle(x, y, (fraction * radius));

      var computedColor = '#' + Math.ceil((numberOfCircles - i) * whiteMultiple).toString(16);
      circle.attr({fill: computedColor});

      group.append(circle);
    }

    var bBox = group.getBBox();
    var centerX = bBox.cx;

    var textNode = buildTextNode(text, centerX, bBox.y2 + 20, true);
    textNode.attr({filter: null});
    group.append(textNode);

    return group;
  }


  var blurFilter = paper.filter(Snap.filter.blur(1, 1));

  var group = graveButton(150, 100, 100, 'Hello!', 3);
  group.attr({filter: blurFilter});

  var branchButton = new BranchGroup(group);

  var wasTriggered = false;
  var branch;
  group.click(function () {
    if (!wasTriggered) {
      group.attr({filter: ''});
      wasTriggered = true;
      branch = branchButton.makeBranchTo(150, 490, 10, 4);
    } else {
      group.attr({filter: blurFilter});
      wasTriggered = false;
      branch.destroyBranch();
    }
  });


</script>


</body>
</html>
